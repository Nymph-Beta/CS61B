### Linked List Performance Puzzle

**链表查询瓶颈**
 在 `DLList` 中，仅持有首尾指针意味着 `get(i)` 必须沿链走到第 *i* 个节点；最坏要走 ≈ *N*/2 步，时间复杂度 Θ(N)，而 `getLast()` 始终 O(1) [Josh Hug](https://joshhug.gitbooks.io/hug61b/content/chap2/chap25.html)。

**数组 O(1) 随机访问**
 Java 数组支持用下标常量时间访问，因此用数组存储元素可以让 `get(i)` 变为 O(1)。于是引入 **AList**：逻辑上仍是“列表”，底层换成动态数组。

**Optional Exercise 2.5.1:** Try to build an AList class that supports `addLast`, `getLast`, `get`, and `size` operations. Your AList should work for any size array up to 100. For starter code, see https://github.com/Berkeley-CS61B/lectureCode/tree/master/lists4/DIY.

```java
public class Alist{
    private int[] items;
    private int size;
    
    public Alist(){
        items = new int[100];
        size = 0;
    }
    
    public void addLast(int x){
        items[size++] = x;
    }
    public int getLast(){
        return items[size - 1];
    }
    public int get(int i){ 
        return items[i]; 
    }
    public int size(){ 
        return size; 
    }
}
```

- The position of the next item to be inserted (using `addLast`) is always `size`.
  下一个待插入项的位置（使用 `addLast` 时）始终是 `size` 。
- The number of items in the AList is always `size`.
  AList 中的项目数量始终是 `size` 。
- The position of the last item in the list is always `size - 1`.
  列表中最后一项的位置始终是 `size - 1` 。

```java
public int removeLast(){
    if (size == 0) {
        throw new NoSuchElementException("AList is empty");
    }
    //int tmp = items[size - 1];
    int tmp = getLast();
    //items[size - 1] = null; 对int[]不需要置null
    size--;
    
    return tmp;
}
```

### Naive Resizing Arrays

```java
int[] a = new int[size + 1];
System.arraycopy(items, 0, a, 0, size);
a[size] = 11;
items = a;
size = size + 1;
```

在 Java 中，解决方案是直接创建一个能容纳新数据的新数组。数组本身并没有改变大小，只是创建了一个尺寸更大的新数组。

但插入 100 000 次要比 `SLList` **慢 10⁵ 倍**（时间曲线呈抛物线）

**Exercise 2.5.4:** Try to implement the `addLast(int i)` method to work with resizing arrays.

```java
public void insertBack(int x){
    if(size == items.length){
        /*int[] a = new int[size + 1];
		System.arraycopy(items, 0, a, 0, size);
		items = a;
		*/
        resize(size + 1);
    }
    items[size++] = x;
    //size++;
}

private void resize(int num){
    //int[] a = new int[size + num];
    int[] a = new int[num];
	System.arraycopy(items, 0, a, 0, size);
	items = a;
}
```

### Analyzing the Naive Resizing Array

**Exercise 2.5.5:** Suppose we have an array of size 100. If we call insertBack two times, how many total boxes will we need to create and fill throughout this entire process? How many total boxes will we have at any one time, assuming that garbage collection happens as soon as the last reference to an array is lost?

203

**Exercise 2.5.6:** Starting from an array of size 100, approximately how many memory boxes get created and filled if we call `addLast` 1,000 times?

599,500 + 1,000 = 600,500

这说明了为什么 `+1` 扩容策略是一个糟糕的主意。操作次数以二次方增长（约 N²/2），速度非常慢。

### Geometric Resizing

可以通过以乘法而非加法的方式扩大数组容量来解决性能问题。也就是说，不再添加与某个调整因子 `RFACTOR` 等量的内存单元。

```java
public void insertBack(int x) {
    if (size == items.length) {
           resize(size * RFACTOR);
    }
    items[size] = x;
    size += 1;
}
```

### Memory Performance

新的insertBack存在一个主要问题。假设我们插入了 10 亿个元素，随后又移除了 9.9 亿个元素。这种情况下，我们实际只使用了 1000 万个内存单元，导致 99%的空间完全闲置。

##### downsize array

定义一个"使用率"R，其值等于列表当前元素数量除以 `items` 数组的长度。

定义 **使用率 R = size / items.length**，在典型实现中，当 R 降至 0.25 以下时，我们会将数组大小减半。

### Generic ALists

Just as we did before, we can modify our `AList` so that it can hold any data type, not just integers. To do this, we again use the special angle braces notation in our class and substitute our arbitrary type parameter for integer wherever appropriate.

由于泛型实现方式中存在一个晦涩的问题，Java 不允许我们创建泛型对象的数组。也就是说，不能这样做：

```java
Glorp[] items = new Glorp[8];
```

相反，必须使用下面这种略显笨拙的语法：

```java
Glorp[] items = (Glorp []) new Object[8];
```

另一个改变是将"删除"的条目置为 null。之前没有理由将已删除元素清零，但对于泛型对象，需要清空存储的对象引用。

这是为了避免"内存滞留"。请记住，Java 只有在丢失最后一个引用时才会销毁对象。如果未能将引用置空，Java 就不会回收已添加到列表中的对象。