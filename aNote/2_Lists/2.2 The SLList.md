
2.1 节创建的IntList 类是一种"裸递归 "的数据结构，使用起来相当别扭，代码难以阅读和维护。
现在将创建一个新类 SLList，它与程序员在现代语言中使用的列表实现更为相似。
## Improvement

### 1. 重构
IntList --> IntNode
```
public class IntNode {
    public int item;
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

由于 IntNodes 很难操作，我们将创建一个名为 SLList 的单独类，用户使与其交互。
```
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null);
    }
}
```

通过创建一个项目来比较IntList和SLList：SLList 向用户隐藏了存在空链接的细节。
```
IntList L1 = new IntList(5, null);
SLList L2  = new SLList(5);
```

通过添加一个 addFirst 和 getFirst 方法来进一步比较

```
/** Adds an item to the front of the list. */
public void addFirst(int x){
	first = new IntNode(x, first)
}

/** Restrieves the front item from the list */
public class getFirst(){
	return first.item
}


public static void main(String[] args){
	SLList L = new SLList(15);
	L.addFirst(10);
	L.addFirst(5);
	int x = L.getFirst();
```
}

Compare:
```
IntList L = new IntList(15, null);
L = new IntList(10, L);
L = new IntList(5, L);
int x = L.first;
```

SLList 类充当了列表用户与赤裸裸的递归数据结构之间的中间人。

---
**Exercise 2.2.1**: The curious reader might object and say that the `IntList` would be just as easy to use if we simply wrote an `addFirst` method. Try to write an `addFirst` method to the `IntList` class. You'll find that the resulting method is tricky as well as inefficient.


```
public void addFirst(int x){
	IntLst newnode =  new IntList(this.first, this.rest);
	this.first = x;
	this.rest = newNode;
}
```
每次添加一个新元素时，实际上是在创建新的节点，并将所有的内容向后移动。这种操作在链表非常大的时候效率会变得很低。另外该方法直接操作了递归数据结构，可能会让用户意外修改链表中间的元素。这种操作不太安全，也不符合封装的原则。

---

### 2. 私有
SLList 可以被绕过，来访问原始的数据结构。
```
SLList L = new SLList(15);
L.addFirst(10);
L.first.next.next = L.first.next;
```
这样就会产生一个无限循环的畸形列表。为了解决这个问题，可以修改 SLList 类，使第一个变量使用 private 关键字声明。

```
public class SLList {
    private IntNode first;
...
```
私有变量和方法只能由同一 .java 文件中的代码访问。若外部类想要访问，会产生产生 First has private access in SLList 错误。
### 3. 嵌套类
```
public class SLList {
       public class IntNode {
            public int item;
            public IntNode next;
            public IntNode(int i, IntNode n) {
                item = i;
                next = n;
            }
       }

       private IntNode first; 

       public SLList(int x) {
           first = new IntNode(x, null);
       } 
...
```

如果嵌套类不需要使用 SLList 的任何实例方法或变量，则可以将嵌套类声明为 static，如下所示。将嵌套类声明为 static 意味着静态类内部的方法不能访问外层类的任何成员。在本例中，这意味着 IntNode 中的任何方法都不能访问 first、addFirst 或 getFirst。

---
**Exercise 2.2.2** Delete the word `static` as few times as possible so that [this program](https://joshhug.gitbooks.io/hug61b/content/chap2/exercises/Government.java) compiles (Refresh the page after clicking the link and making sure the url changed). Make sure to read the comments at the top before doing the exercise.

- `King`、`Mayor`、`Accountant` 和 `Thief` 需要访问 `Government` 的实例方法或变量，所以它们不能是 `static`。
- `Peasant` 和 `Explorer` 可以保持 `static`，因为它们不直接与 `Government` 的实例方法或变量交互。
- 添加 `main` 方法，以便能够直接运行这个 Java 文件，可以将 `main` 方法添加到 `Government` 类中。
---
#### addLast() and size()

```
/** Adds an item to tehe end of the list. */
public void addLastIterative(int x){
	IntNode p = first;
	while(p != null)
		p = p.next;
	p.next = new IntNode(x, null)
}
```
```
public void addLast(int x) { 
	if (first == null) { 
		first = new IntNode(x, null); 
	} else { 
		addLastRecursive(first, x); 
	} 
}
private void addLastRecursive(IntNode node, int x) { 
	if (node.next == null) { 
		node.next = new IntNode(x, null); 
	} else { 
		addLastRecursive(node.next, x); 
	} 
}
```

在 IntList 中，size 的递归调用通过`return 1 + this.rest.size()`实现。对于 SLList 来说，因为SLList 没有 rest 变量，这种方法并不合理。
我们将创建一个与底层裸递归数据结构交互的私有辅助方法。
```
/** Returns the size of the list starting at IntNode p. */
private static int size(IntNode p) {
    if (p.next == null) {
        return 1;
    }

    return 1 + size(p.next);
}

public int size() {
    return size(first);
}
```

### Cache
上面编写的 size 方法。假设在大小为 1,000 的列表中，size 需要 2 秒。我们预计，在大小为 1,000,000 的列表中，size 方法将耗时 2,000 秒
可以重写 size 方法，只需在 SLList 类中添加一个 size 变量来跟踪当前的大小，这样无论列表有多大，所需的时间都是一样的。
这种保存重要数据以加快检索速度的做法有时被称为Cache。
```
public class SLList{
	... /* IntNode declaration omitted. */
	private IntNode first;
	private int size;

	public SLList(int x){
		first = new IntNode(x, first);
		size += 1;
	}

	public int size(){
		return size;
	}

}
```
This modification makes our `size` method incredibly fast, no matter how large the list. Of course, it will also slow down our `addFirst` and `addLast` methods, and also increase the memory of usage of our class, but only by a trivial amount.

### The Empty List
SLList的另一个优点：可以轻松实现一个构造函数来创建一个空 list。
如列表为空，则首先设置为空：
```
public SlList(){
	first = null;
	size = 0;
}
```
但是，若插入空列表，回到是刚才定义的addList方法崩溃：由于 first 为空，在下面 while (p.next != null) 中访问 p.next 的尝试会导致空指针异常。

---
Fixed：
**Exercise 2.2.3** Fix the `addLast` method. Starter code [here](https://github.com/Berkeley-CS61B/lectureCode/blob/master/lists2/DIY/fixAddLast/SLList.java).
添加条件判断语句
```
    public void addLast(int x){
       if (first == null){
           first = new IntNode(x, first, first);
           return；
       }else{
           IntNode p = first;
           while(p.next != null){
               p= p.next;
           }
           p.next = new IntNode(x, null);
       }
       size += 1;
    }
```

### Sentinel Nodes 哨兵节点
必要时应避免使用如上所示的特殊情况代码。我们希望尽可能控制复杂性。
一个更简洁但不那么明显的解决方案是让所有 SLList 都 "相同"，即使它们是空的。为此，我们可以创建一个始终存在的特殊节点，我们称之为Sentinel Nodes。Sentinel Nodes将保存一个值，但我们并不关心这个值。（空的头部节点）
例如，由 SLList L = new SLList() 创建的空列表如下所示：
![[Pasted image 20240815201600.png]]
包含项目 5、10 和 15 的 SLList 如下所示：
![[Pasted image 20240815201629.png]]```
```
public void addLast(int x) {
    size += 1;
    IntNode p = sentinel;
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```
As you can see, this code is much much cleaner!

### Task
 Recommend that you wait until after you've finished the next section of this book before beginning project 1 and you're welcome to now begin Lab 2.