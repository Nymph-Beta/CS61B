**对SSList一步步进行改进**

2.1 节创建的IntList 类是一种"裸递归 "的数据结构，使用起来相当别扭，代码难以阅读和维护。

for example:

```java
// 创建列表 [5, 10, 15]
IntList L = new IntList(15, null);           // 必须从后往前建
L = new IntList(10, L);                      // 每次都要重新赋值
L = new IntList(5, L);                       // 容易忘记重新赋值

// 想要在前面添加元素
L = new IntList(1, L);                       // 又要重新赋值

// 可能犯的错误
IntList badList = new IntList(5, null);
new IntList(10, badList);                    // 忘记赋值！badList还是[5]
```

现在将创建一个新类 SLList，它与程序员在现代语言中使用的列表实现更为相似。

## Improvement

### 1. 重构
IntList --> IntNode

```java
// IntList
// L既代表整个列表，又代表列表的第一个节点
public class IntList{
	public int first;
	public IntList rest;
	
	public IntList(int f, IntList r){
		first = f;
		rest = r;
	}
}
```

```java
// IntNode 更反应本质：一个节点
public class IntNode {
    public int item;
    public IntNode next;

    public IntNode(int i, IntNode n) {
        item = i;
        next = n;
    }
}
```

由于 IntNodes 很难操作，我们将创建一个名为 SLList 的单独类，用户使与其交互。
```java
// 一个中间层
public class SLList {
    public IntNode first;

    public SLList(int x) {
        first = new IntNode(x, null); // 自动处理null
    }
}
```

通过创建一个项目来比较IntList和SLList：SLList 向用户隐藏了存在空链接的细节。
```java
IntList L1 = new IntList(5, null);
SLList L2  = new SLList(5);
```

通过添加一个 addFirst 和 getFirst 方法来进一步比较

```java
/** Adds an item to the front of the list. */
public void addFirst(int x){
	first = new IntNode(x, first) //新结点指向原来的first
}

/** Restrieves the front item from the list */
public int getFirst(){
	return first.item;
}


public static void main(String[] args){
	SLList L = new SLList(15);
	L.addFirst(10);
	L.addFirst(5);
	int x = L.getFirst();
}
```
Compare:
```java
IntList L = new IntList(15, null);
L = new IntList(10, L); // 必须重新赋值
L = new IntList(5, L);
int x = L.first; // 直接访问了内部数据
```

SLList 类充当了列表用户与赤裸裸的递归数据结构之间的中间人。

---
**Exercise 2.2.1**: The curious reader might object and say that the `IntList` would be just as easy to use if we simply wrote an `addFirst` method. Try to write an `addFirst` method to the `IntList` class. You'll find that the resulting method is tricky as well as inefficient.


```java
// 方案1：修改当前对象（不可行）
public void addFirst(int x) {
    // 想要：把当前对象变成新的头节点
    // 但这在Java中是不可能的！
    // 不能改变this指向的对象
}

// 方案2：返回新的列表（破坏了void方法的预期）
public IntList addFirst(int x) {
    return new IntList(x, this);
}

//方案3：移动所有数据
public void addFirst(int x){
	IntLst newnode =  new IntList(this.first, this.rest);
	this.first = x;
	this.rest = newNode;
}
```
每次添加一个新元素时，实际上是在创建新的节点，并将所有的内容向后移动。这种操作在链表非常大的时候效率会变得很低。另外该方法直接操作了递归数据结构，可能会让用户意外修改链表中间的元素。这种操作不太安全，也不符合封装的原则。

---

### 2. 私有
SLList 可以被绕过，来访问原始的数据结构。
```java
SLList L = new SLList(15);
L.addFirst(10);
L.first.next.next = L.first.next;
```
这样就会产生一个无限循环的畸形列表。为了解决这个问题，可以修改 SLList 类，使第一个变量使用 private 关键字声明。

```Java
public class SLList {
    private IntNode first;
...
```
私有变量和方法只能由同一 .java 文件中的代码访问。若外部类想要访问，会产生产生 First has private access in SLList 错误，比如下面这个例子。

```
public classSKLTroubleMaker{
	public static void main(string[] args){
		SLList L = new SLList(15);
		L.addFirst(10);
		L.first.next.first = L.first.next;
	}
}
```



### 3. 嵌套类

Java提供了将一个类声明嵌入到另一个类声明的功能

IntNode只在SLList中使用，避免全局命名污染，实现更新颗粒度的控制：

```Java
// IntNode：纯粹的数据载体，SLList：列表管理者
public class SLList {
       public class IntNode {
            public int item;
            public IntNode next;
            public IntNode(int i, IntNode n) {
                item = i;
                next = n;
            }
       }

       private IntNode first; 

       public SLList(int x) {
           first = new IntNode(x, null);
       } 
...
```

如果嵌套类不需要使用 SLList 的任何实例方法或变量，则可以将嵌套类声明为 static，如下所示。将嵌套类声明为 static 意味着静态类内部的方法不能访问外层类的任何成员。在本例中，这意味着 IntNode 中的任何方法都不能访问 first、addFirst 或 getFirst。

---
**Exercise 2.2.2** Delete the word `static` as few times as possible so that [this program](https://joshhug.gitbooks.io/hug61b/content/chap2/exercises/Government.java) compiles (Refresh the page after clicking the link and making sure the url changed). Make sure to read the comments at the top before doing the exercise.

- `King`、`Mayor`、`Accountant` 和 `Thief` 需要访问 `Government` 的实例方法或变量，所以它们不能是 `static`。
- `Peasant` 和 `Explorer` 可以保持 `static`，因为它们不直接与 `Government` 的实例方法或变量交互。
- 添加 `main` 方法，以便能够直接运行这个 Java 文件，可以将 `main` 方法添加到 `Government` 类中。
---
#### addLast() and size()

```java
/** Adds an item to tehe end of the list. */
// 简单迭代实现
public void addLastIterative(int x){
	IntNode p = first;
	// while(p != null)
    while(p.next != null)
		p = p.next;
	p.next = new IntNode(x, null)
}
```
```java
public void addLast(int x) { 
	if (first == null) { 
		first = new IntNode(x, null); 
	} else { 
		addLastRecursive(first, x); 
	} 
}
private void addLastRecursive(IntNode node, int x) { 
	if (node.next == null) { 
		node.next = new IntNode(x, null); 
	} else { 
		addLastRecursive(node.next, x); 
	} 
}
```

在 IntList 中，size 的递归调用通过`return 1 + this.rest.size()`实现。对于 SLList 来说，因为SLList 没有 rest 变量，这种方法并不合理。
我们将创建一个与底层裸递归数据结构交互的私有辅助方法。

```java
/** Returns the size of the list starting at IntNode p. */
private static int size(IntNode p) {
    if(p == null){
        return 0
    }
    
    if (p.next == null) {
        return 1;
    }

    return 1 + size(p.next);
}

public int size() {
    return size(first);
}
```

### Cache
上面编写的 size 方法。假设在大小为 1,000 的列表中，size 需要 2 秒。我们预计，在大小为 1,000,000 的列表中，size 方法将耗时 2,000 秒
可以重写 size 方法，只需在 SLList 类中添加一个 size 变量来跟踪当前的大小，这样无论列表有多大，所需的时间都是一样的。
这种保存重要数据以加快检索速度的做法有时被称为Cache。

```java
public class SLList{
	... /* IntNode declaration omitted. */
	private IntNode first;
	private int size; // 调用一个变量充当辅助方法

	public SLList(int x){
		// first = new IntNode(x, first);
        first = new IntNode(x, null);
		size = 1;
	}
    
    public void addFirst(int x){
        first = new IntNode(x, first);
        size += 1;
    }

	public int size(){
		return size; // O(1)
	}

}
```
This modification makes our `size` method incredibly fast, no matter how large the list. Of course, it will also slow down our `addFirst` and `addLast` methods, and also increase the memory of usage of our class, but only by a trivial amount.

### The Empty List
SLList的另一个优点：可以轻松实现一个构造函数来创建一个空 list。
如列表为空，则首先设置为空：

```java
public SlList(){
	first = null;
	size = 0;
}
```
但是，若插入空列表，回到是刚才定义的addList方法崩溃：由于 first 为空，在下面 while (p.next != null) 中访问 p.next 的尝试会导致空指针异常。

---
Fixed：
**Exercise 2.2.3** Fix the `addLast` method. Starter code [here](https://github.com/Berkeley-CS61B/lectureCode/blob/master/lists2/DIY/fixAddLast/SLList.java).
添加条件判断语句

```java
    public void addLast(int x){
       if (first == null){
           first = new IntNode(x, null);
           return；
       }else{
           IntNode p = first;
           while(p.next != null){
               p= p.next;
           }
           p.next = new IntNode(x, null);
       }
       size += 1;
    }
```

### Sentinel Nodes 哨兵节点
必要时应避免使用如上所示的特殊情况代码。我们希望尽可能控制复杂性。
一个更简洁但不那么明显的解决方案是让所有 SLList 都 "相同"，即使它们是空的。为此，我们可以创建一个始终存在的特殊节点，我们称之为Sentinel Nodes。Sentinel Nodes将保存一个值，但我们并不关心这个值。（空的头部节点）
例如，由 SLList L = new SLList() 创建的空列表如下所示：
![[Pasted image 20240815201600.png]]
包含项目 5、10 和 15 的 SLList 如下所示：
![[Pasted image 20240815201629.png]]```

```java
public void addLast(int x) {
    size += 1;
    IntNode p = sentinel;
    while (p.next != null) {
        p = p.next;
    }

    p.next = new IntNode(x, null);
}
```
As you can see, this code is much much cleaner!

### Task
 Recommend that you wait until after you've finished the next section of this book before beginning project 1 and you're welcome to now begin Lab 2.



最终的SLList实现：

```java
public class SLList {
    private static class IntNode {
        public int item;
        public IntNode next;
        
        public IntNode(int i, IntNode n) {
            item = i;
            next = n;
        }
    }
    
    private IntNode sentinel;
    private int size;
    
    /** 创建空列表 */
    public SLList() {
        sentinel = new IntNode(63, null);
        size = 0;
    }
    
    /** 创建包含单个元素的列表 */
    public SLList(int x) {
        sentinel = new IntNode(63, null);
        sentinel.next = new IntNode(x, null);
        size = 1;
    }
    
    /** 在前面添加元素 */
    public void addFirst(int x) {
        sentinel.next = new IntNode(x, sentinel.next);
        size += 1;
    }
    
    /** 在末尾添加元素 */
    public void addLast(int x) {
        size += 1;
        IntNode p = sentinel;
        while (p.next != null) {
            p = p.next;
        }
        p.next = new IntNode(x, null);
    }
    
    /** 获取第一个元素 */
    public int getFirst() {
        if (size == 0) {
            throw new RuntimeException("Empty list has no first element");
        }
        return sentinel.next.item;
    }
    
    /** 获取列表大小 */
    public int size() {
        return size;
    }
    
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        IntNode p = sentinel.next;
        while (p != null) {
            sb.append(p.item);
            if (p.next != null) sb.append(", ");
            p = p.next;
        }
        sb.append("]");
        return sb.toString();
    }
}
```

测试代码：

```java
public class SLListTest {
    public static void main(String[] args) {
        // 测试空列表
        SLList empty = new SLList();
        System.out.println("Empty list: " + empty);
        System.out.println("Size: " + empty.size());
        
        // 测试addFirst
        SLList list = new SLList();
        list.addFirst(10);
        list.addFirst(5);
        System.out.println("After addFirst: " + list);
        
        // 测试addLast
        list.addLast(20);
        list.addLast(30);
        System.out.println("After addLast: " + list);
        
        // 测试性能
        long start = System.nanoTime();
        for (int i = 0; i < 100000; i++) {
            list.size();  // O(1)操作
        }
        long end = System.nanoTime();
        System.out.println("100,000 size() calls took: " + (end - start) + " nanoseconds");
    }
}
```

